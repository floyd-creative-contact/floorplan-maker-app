<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
<script>
  const canvas = new fabric.Canvas('floorplan-canvas', {
    selection: true,
    backgroundColor: '#fff',
    preserveObjectStacking: true
  });

  const gridSize = 50;
  let snapping = {{SNAP_TO_GRID}};
  let showGrid = {{SHOW_GRID}};
  let currentTool = "{{TOOL}}";
  let polygonSides = parseInt("{{POLYGON_SIDES}}") || 5;

  // Draw grid lines
  function drawGrid(size) {
    if (!showGrid) return;
    for (let i = 0; i < canvas.getWidth(); i += size) {
      canvas.add(new fabric.Line([i, 0, i, canvas.getHeight()], {
        stroke: '#eee',
        selectable: false,
        evented: false,
        excludeFromExport: true
      }));
    }
    for (let i = 0; i < canvas.getHeight(); i += size) {
      canvas.add(new fabric.Line([0, i, canvas.getWidth(), i], {
        stroke: '#eee',
        selectable: false,
        evented: false,
        excludeFromExport: true
      }));
    }
  }

  drawGrid(gridSize);

  // Snap objects to grid while moving
  canvas.on('object:moving', function (opt) {
    if (!snapping) return;
    opt.target.set({
      left: Math.round(opt.target.left / gridSize) * gridSize,
      top: Math.round(opt.target.top / gridSize) * gridSize
    });
  });

  // Variables for drawing
  let isDrawing = false;
  let startX, startY;
  let shape;

  // Mouse down event - start drawing
  canvas.on('mouse:down', function(opt) {
    if (currentTool === null) return;

    isDrawing = true;
    const pointer = canvas.getPointer(opt.e);
    startX = pointer.x;
    startY = pointer.y;

    switch(currentTool) {
      case "Line":
        shape = new fabric.Line([startX, startY, startX, startY], {
          stroke: 'black', strokeWidth: 2, selectable: true
        });
        break;
      case "Rectangle":
        shape = new fabric.Rect({
          left: startX,
          top: startY,
          width: 0,
          height: 0,
          fill: 'transparent',
          stroke: 'black',
          strokeWidth: 2,
          selectable: true
        });
        break;
      case "Circle/Ellipse":
        shape = new fabric.Ellipse({
          left: startX,
          top: startY,
          rx: 0,
          ry: 0,
          fill: 'transparent',
          stroke: 'black',
          strokeWidth: 2,
          selectable: true
        });
        break;
      case "Arc":
        shape = new fabric.Path(`M ${startX} ${startY} A 0 0 0 0 1 ${startX} ${startY}`, {
          fill: '',
          stroke: 'black',
          strokeWidth: 2,
          selectable: true
        });
        break;
      case "Polygon":
        shape = new fabric.Polygon([], {
          left: startX,
          top: startY,
          fill: 'transparent',
          stroke: 'black',
          strokeWidth: 2,
          selectable: true
        });
        break;
    }

    if (shape) {
      canvas.add(shape);
    }
  });

  // Mouse move event - update shape size
  canvas.on('mouse:move', function(opt) {
    if (!isDrawing || !shape) return;

    const pointer = canvas.getPointer(opt.e);
    const curX = pointer.x;
    const curY = pointer.y;

    switch(currentTool) {
      case "Line":
        shape.set({ x2: curX, y2: curY });
        break;
      case "Rectangle":
        const width = curX - startX;
        const height = curY - startY;
        shape.set({ width: Math.abs(width), height: Math.abs(height) });
        if (width < 0) shape.set({ left: curX });
        if (height < 0) shape.set({ top: curY });
        break;
      case "Circle/Ellipse":
        const rx = Math.abs(curX - startX) / 2;
        const ry = Math.abs(curY - startY) / 2;
        shape.set({ rx: rx, ry: ry });
        shape.set({ left: Math.min(startX, curX), top: Math.min(startY, curY) });
        break;
      case "Arc":
        // For simplicity, draw a quarter arc using Path
        // We'll just update the arc radius and end point here
        const radiusX = Math.abs(curX - startX);
        const radiusY = Math.abs(curY - startY);
        const largeArcFlag = 0;
        const sweepFlag = 1;
        const path = `M ${startX} ${startY} A ${radiusX} ${radiusY} 0 ${largeArcFlag} ${sweepFlag} ${curX} ${curY}`;
        shape.set({ path: new fabric.Path(path).path });
        break;
      case "Polygon":
        // Dynamically create a regular polygon centered at startX/startY
        const radius = Math.sqrt((curX - startX) ** 2 + (curY - startY) ** 2);
        const points = [];
        for (let i = 0; i < polygonSides; i++) {
          const angle = (Math.PI * 2 * i) / polygonSides - Math.PI / 2;
          points.push({
            x: radius * Math.cos(angle),
            y: radius * Math.sin(angle)
          });
        }
        shape.set({ points: points, left: startX, top: startY });
        break;
    }
    canvas.renderAll();
  });

  // Mouse up event - finish drawing
  canvas.on('mouse:up', function(opt) {
    isDrawing = false;
    shape = null;
  });
</script>
